<head>
  <style> body { margin: 0; } </style>

  <script src="//unpkg.com/three"></script>
  <script src="//unpkg.com/dat.gui"></script> 
  <script src="//unpkg.com/three-spritetext"></script>

  <script src="//unpkg.com/3d-force-graph"></script>

  <script src="dataformating-2.js"></script>
  <!--<script src="../../dist/3d-force-graph.js"></script>-->
</head>

<body>
  <div id="3d-graph"></div>
  <div style="position: fixed; bottom: 0; width: 100%; background-color: rgba(51, 51, 51, 0.7); color: #fff; text-align: center; padding: 10px 0; box-shadow: 0px -2px 5px rgba(0,0,0,0.3);">
    <button style="margin: 0 10px; padding: 5px 15px; background-color: #555; border: none; border-radius: 5px; color: #fff; cursor: pointer; transition: background-color 0.3s;">Button 1</button>
    <button style="margin: 0 10px; padding: 5px 15px; background-color: #555; border: none; border-radius: 5px; color: #fff; cursor: pointer; transition: background-color 0.3s;">Button 2</button>
    <button style="margin: 0 10px; padding: 5px 15px; background-color: #555; border: none; border-radius: 5px; color: #fff; cursor: pointer; transition: background-color 0.3s;">Button 3</button>
    <button style="margin: 0 10px; padding: 5px 15px; background-color: #555; border: none; border-radius: 5px; color: #fff; cursor: pointer; transition: background-color 0.3s;">Button 4</button>
    <button style="margin: 0 10px; padding: 5px 15px; background-color: #555; border: none; border-radius: 5px; color: #fff; cursor: pointer; transition: background-color 0.3s;">Button 5</button>
  </div>
  <div style="position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%); z-index: 1000;">
    <input type="text" id="searchInput" placeholder="Enter node ID..." style="padding: 5px;">
    <button onclick="searchNode()" style="padding: 5px 10px;">Search</button>
</div>
  <script>    
    const highlightNodes = new Set();
    const Graph = ForceGraph3D()
    .backgroundColor('#101020')
      (document.getElementById('3d-graph'))
        .graphData(window.transformedData)
        .nodeAutoColorBy('group')
        // .nodeColor(node => {
        //   if (highlightNodes.has(node)) {
        //       return node === targetNode ? '#71ffff4d' : '#deff00';
        //   } else {
        //       return '#00ffff'; // Reduced opacity for non-neighboring nodes
        //   }
        // })
        .nodeThreeObject(node => {
          const sprite = new SpriteText(node.id);
          sprite.material.depthWrite = false; // make sprite background transparent
          sprite.color = node.color;
          sprite.textHeight = 4;
          return sprite;
        })
        .onNodeClick(node => {
          // Aim at node from outside it
          const distance = 80;
          const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);

          const newPos = node.x || node.y || node.z
            ? { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }
            : { x: 0, y: 0, z: distance }; // special case if node is in (0,0,0)

          Graph.cameraPosition(
            newPos, // new position
            node, // lookAt ({ x, y, z })
            3000  // ms transition duration
          );
        });


    //Define GUI
    const Settings = function() {
      this.strength = 20;
    };

    const linkForce = Graph
      .d3Force('link')
      .distance(link => settings.strength);

    const colorParam = {
      backgroundColor: Graph.backgroundColor(),
    };

    const settings = new Settings();
    const gui = new dat.GUI();

    const controllerOne = gui.add(settings, 'strength', 0, 100);
    const controller2 = gui.addColor(colorParam, 'backgroundColor').onChange((value) => Graph.backgroundColor(value.toString()));

    controllerOne.onChange(updateLinkDistance);

    function updateLinkDistance() {
      linkForce.distance(link => settings.strength);
      Graph.numDimensions(3); // Re-heat simulation
    }


    const highlightLinks = new Set();

function searchNode() {
    const nodeId = document.getElementById('searchInput').value;
    const graphData = Graph.graphData();
    const targetNode = graphData.nodes.find(node => node.id === nodeId);

    if (targetNode) {
        // Clear previous highlights
        highlightNodes.clear();
        highlightLinks.clear();

        // Find all links connected to the target node
        const connectedLinks = graphData.links.filter(link => 
            (link.source.id || link.source) === targetNode.id || 
            (link.target.id || link.target) === targetNode.id
        );

        // Extract the neighboring nodes and highlight the links
        const neighbors = connectedLinks.map(link => {
            highlightLinks.add(link);
            return (link.source.id || link.source) === targetNode.id ? link.target : link.source;
        });
        
        // Highlight the target node and its neighbors
        highlightNodes.add(targetNode);
        neighbors.forEach(neighbor => highlightNodes.add(neighbor));

        // Adjust the camera position to focus on the target node
        Graph.cameraPosition(
            { x: targetNode.x, y: targetNode.y, z: targetNode.z-100}, // new position
            targetNode, // lookAt ({ x, y, z })
            1000  // ms transition duration
        );

        // Update the graph to reflect the new highlighting
        Graph.nodeOpacity(node => {
            if (highlightNodes.has(node)) {
                return 1;  // Fully opaque for highlighted nodes
            } else {
                return 0.2;  // Semi-transparent for non-highlighted nodes
            }
        });

        Graph.linkOpacity(link => {
            if (highlightLinks.has(link)) {
                return 1;  // Fully opaque for highlighted links
            } else {
                return 0.2;  // Semi-transparent for non-highlighted links
            }
        });
    } else {
        console.log("Node with ID " + nodeId + " not found!");
    }
    Graph.nodeThreeObject();
    Graph.refresh();
}

    



    // Spread nodes a little wider
    // Graph.d3Force('charge').strength(-1000);

    // // Graph.scene().add(mesh);
    // const geometry = new THREE.BoxGeometry( 100, 100, 100 ); 
    // const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} ); 
    // const cube = new THREE.Mesh( geometry, material ); 
    // cube.position.set(-100, -50, 0);
    // cube.rotation.set(0, 0, 0);

    // // console.log(Graph.position.graph2ScreenCoords(1,2,3));
    // Graph.scene().add(cube);

    

  </script>
</body>