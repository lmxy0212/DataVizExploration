<head>
  <style> body { margin: 0; } </style>

  <script src="//unpkg.com/three"></script>
  <script src="//unpkg.com/dat.gui"></script> 
  <script src="//unpkg.com/three-spritetext"></script>

  <script src="//unpkg.com/3d-force-graph"></script>

  <script src="dataformating-new.js"></script>
  <!--<script src="../../dist/3d-force-graph.js"></script>-->
</head>

<body>
  <div id="3d-graph"></div>
  <div style="position: fixed; bottom: 0; width: 100%; background-color: transparent; color: #fff; text-align: center; padding: 0; margin-bottom: 20px;">
    <input type="text" id="searchInput" placeholder="Enter node ID...">
    <button class="bottom-button" onclick="searchNode()">SubGraph</button>
    <button class="bottom-button" onclick="locateNode()">Locate</button>
    <button class="bottom-button" onclick="resetGraph()">Reset</button>
  </div>
  
  <!-- <div id="taskbar">
    <button class="taskbar-button">Button 1</button>
    <button class="taskbar-button">Button 2</button>
    <button class="taskbar-button">Button 3</button>
    <button class="taskbar-button">Button 4</button>
    <button class="taskbar-button" onclick="resetGraph()">Reset</button>
  </div> -->
  
  <style>
    #searchInput {
      margin: 0 10px;
      padding: 5px;
      width: 150px;
      border-radius: 5px;
      border: none;
      background-color: rgba(51, 51, 51, 0.7);
      color: #fff;
    }

    .bottom-button {
      margin: 0 10px;
      padding: 5px 15px;
      width: 100px;
      background-color: #555;
      border: none;
      border-radius: 5px;
      color: #fff;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    /* #taskbar {
      position: fixed;
      top: 50%;
      right: 10px;
      transform: translateY(-50%);
      background-color: rgba(51, 51, 51, 0.7);
      padding: 10px;
      border-radius: 5px;
      box-shadow: -2px 0px 5px rgba(0,0,0,0.3);
    }

    .taskbar-button {
      display: block;
      margin: 10px 0;
      padding: 5px 15px;
      width: 100px;
      background-color: rgba(85, 85, 85, 0.7);
      border: none;
      border-radius: 5px;
      color: #fff;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .taskbar-button:hover {
      background-color: rgba(119, 119, 119, 0.7);
    } */
  </style>

<script type="importmap">{ "imports": { "three": "//unpkg.com/three/build/three.module.js" }}</script>
<script type="module">
  import { UnrealBloomPass } from '//unpkg.com/three/examples/jsm/postprocessing/UnrealBloomPass.js';
  
  // Your existing code...

  // Initialize the graph
  let Graph = window.Graph;
 
  
  // Ensure UnrealBloomPass is applied
  applyUnrealBloomPass();

  function applyUnrealBloomPass() {
    const bloomPass = new UnrealBloomPass();
    bloomPass.strength = 1.3;
    bloomPass.radius = 0.3;
    bloomPass.threshold = 0;
    Graph.postProcessingComposer().addPass(bloomPass);
  }
</script>
<script>
   const highlightNodes = new Set();
   window.Graph = ForceGraph3D({ controlType: 'fly' });
  
   initializeForceGraph(window.transformedData);

   
    const originalGraphData = JSON.parse(JSON.stringify(window.transformedData));

    //Define GUI
    const Settings = function() {
      this.strength = 20;
    };

    const linkForce = Graph
      .d3Force('link')
      .distance(link => settings.strength);

    const colorParam = {
      backgroundColor: Graph.backgroundColor(),
    };

    const settings = new Settings();
    const gui = new dat.GUI();

    const controllerOne = gui.add(settings, 'strength', 0, 100);
    const controller2 = gui.addColor(colorParam, 'backgroundColor').onChange((value) => Graph.backgroundColor(value.toString()));

    controllerOne.onChange(updateLinkDistance);


    function initializeForceGraph(data){
      Graph = ForceGraph3D()
      // .backgroundColor('#101020')
      .backgroundColor('#000001')
        (document.getElementById('3d-graph'))
          .graphData(data)
          .nodeAutoColorBy('group')
          .nodeThreeObject(node => {
            const sprite = new SpriteText(node.id);
            sprite.material.depthWrite = false; // make sprite background transparent
            sprite.color = node.color;
            sprite.textHeight = 4;
            return sprite;
          })
          .onNodeClick(node => {
            // Aim at node from outside it
            const distance = 100;
            const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);

            const newPos = node.x || node.y || node.z
              ? { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }
              : { x: 0, y: 0, z: distance }; // special case if node is in (0,0,0)

            Graph.cameraPosition(
              newPos, // new position
              node, // lookAt ({ x, y, z })
              3000  // ms transition duration
            );
          });
}

    function updateLinkDistance() {
      linkForce.distance(link => settings.strength);
      Graph.numDimensions(3); // Re-heat simulation
    }

    function resetGraph() {
      // initializeForceGraph(JSON.parse(JSON.stringify(originalGraphData)))
      // initializeForceGraph(window.transformedData);
      // Remove circles
      const scene = Graph.scene();
      const centerCircle = scene.getObjectByName('centerCircle');
      const outerCircle = scene.getObjectByName('outerCircle');
      const innerCircle = scene.getObjectByName('innerCircle');
      if (centerCircle) scene.remove(centerCircle);
      if (outerCircle) scene.remove(outerCircle);
      if (innerCircle) scene.remove(innerCircle);
      Graph.graphData(JSON.parse(JSON.stringify(originalGraphData)));
      Graph.nodeThreeObject();
      Graph.numDimensions(3);
      Graph.cameraPosition({ x: 0, y: 0, z: 1000 }, { x: 0, y: 0, z: 0 }, 1000);
    }

    const highlightLinks = new Set();

//     function searchNode() {
//     const nodeId = document.getElementById('searchInput').value;
//     const graphData = Graph.graphData();
//     const targetNode = graphData.nodes.find(node => node.id === nodeId);

//     if (targetNode) {
//         // Find all links connected to the target node
//         const connectedLinks = graphData.links.filter(link => 
//             (link.source.id || link.source) === targetNode.id || 
//             (link.target.id || link.target) === targetNode.id
//         );

//         // Extract the neighboring nodes
//         const neighbors = connectedLinks.map(link => 
//             (link.source.id || link.source) === targetNode.id ? link.target : link.source
//         );

//         // Find all links connected to the neighbors
//         const secondDegreeLinks = graphData.links.filter(link => 
//             neighbors.some(neighbor => 
//                 (link.source.id || link.source) === neighbor.id || 
//                 (link.target.id || link.target) === neighbor.id
//             )
//         );
//         let secondDegreeNeighbors = secondDegreeLinks.map(link => 
//             neighbors.includes(link.source) ? link.target : link.source
//         );

//         secondDegreeNeighbors = [...new Set(secondDegreeNeighbors)];
//         if (secondDegreeNeighbors.length > 10) {
//             secondDegreeNeighbors.sort((a, b) => b.value - a.value); // assuming nodes have a 'value' property
//             secondDegreeNeighbors = secondDegreeNeighbors.slice(0, 20);
//         }

//         // Combine all nodes and links to be displayed
//         const allNodesToShow = [targetNode, ...neighbors, ...secondDegreeNeighbors];
//         const allLinksToShow = [...connectedLinks, ...secondDegreeLinks];

//         // Filter the nodes and links to only include the target node, its neighbors, and the links connecting them
//         graphData.nodes = graphData.nodes.filter(node => allNodesToShow.includes(node));
//         graphData.links = allLinksToShow;

//         // Update the graph with the filtered data
//         Graph.graphData(graphData);

//         // Adjust the camera position to focus on the target node
//         Graph.onNodeClick(targetNode);
//         Graph.numDimensions(2);
//     } else {
//         console.log(`Node with ID ${nodeId} not found!`);
//     }
// }

  function zoominToNode(node){
    // Aim at node from outside it
    const distance = 100;
    const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);

    const newPos = node.x || node.y || node.z
      ? { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio }
      : { x: 0, y: 0, z: distance }; // special case if node is in (0,0,0)

    Graph.cameraPosition(
      newPos, // new position
      node, // lookAt ({ x, y, z })
      3000  // ms transition duration
    );
  }
  function locateNode(){
    const nodeId = document.getElementById('searchInput').value;
    const graphData = Graph.graphData();
    const targetNode = graphData.nodes.find(node => node.id === nodeId);
    console.log("locating");
    zoominToNode(targetNode);
  }
  function searchNode() {
    const nodeId = document.getElementById('searchInput').value;
    const graphData = Graph.graphData();
    const targetNode = graphData.nodes.find(node => node.id === nodeId);

    if (targetNode) {
        // Find all links connected to the target node
        const connectedLinks = graphData.links.filter(link => 
            (link.source.id || link.source) === targetNode.id || 
            (link.target.id || link.target) === targetNode.id
        );

        // Extract the neighboring nodes
        const neighbors = connectedLinks.map(link => 
            (link.source.id || link.source) === targetNode.id ? link.target : link.source
        );

        // Find all links connected to the neighbors
        const secondDegreeLinks = graphData.links.filter(link => 
            neighbors.some(neighbor => 
                (link.source.id || link.source) === neighbor.id || 
                (link.target.id || link.target) === neighbor.id
            )
        );

        // Extract the second-degree neighboring nodes
        let secondDegreeNeighbors = secondDegreeLinks.map(link => 
            neighbors.includes(link.source) ? link.target : link.source
        );

        // Ensure nodes are not duplicated in secondDegreeNeighbors
        secondDegreeNeighbors = secondDegreeNeighbors.filter(
            node => !neighbors.includes(node) && node !== targetNode
        );

        // Combine all nodes and links to be displayed
        const allNodesToShow = [targetNode, ...neighbors, ...secondDegreeNeighbors];
        const allLinksToShow = [...connectedLinks, ...secondDegreeLinks];

        // Filter the nodes and links to only include the target node, its neighbors, and the links connecting them
        graphData.nodes = graphData.nodes.filter(node => allNodesToShow.includes(node));
        graphData.links = [];

        // Update the graph with the filtered data
        Graph.graphData(graphData);

        // Positioning nodes
        positionNodes(targetNode, neighbors, secondDegreeNeighbors);

        // Adjust the camera position to focus on the target node
        zoominToNode(targetNode);
        
    } else {
        console.log(`Node with ID ${nodeId} not found!`);
    }
}


  function positionNodes(centerNode, firstCircleNodes, secondCircleNodes) {
    // Stop the simulation
    // Graph.d3Force('charge', null);
    // Graph.d3Force('link', null);
    // Graph.d3Force('center', null);
    // Position the center node
    centerNode.x = 0;
    centerNode.y = 0;
    centerNode.z = 0;
    centerNode.fx = centerNode.x;
    centerNode.fy = centerNode.y;
    centerNode.fz = centerNode.z;

    // Position the first circle nodes
    const firstCircleRadius = 100; // Adjust as needed
    firstCircleNodes.forEach((node, idx, arr) => {
        const angle = (idx / arr.length) * 2 * Math.PI;
        node.x = centerNode.fx + firstCircleRadius * Math.cos(angle);
        node.y = centerNode.fy + firstCircleRadius * Math.sin(angle);
        node.z = 0;
        node.fx = node.x;
        node.fy = node.y;
        node.fz = node.z;
    });

    // Position the second circle nodes
    const secondCircleRadius = 200; // Adjust as needed
    secondCircleNodes.forEach((node, idx, arr) => {
        const angle = (idx / arr.length) * 2 * Math.PI;
        node.x = centerNode.fx + secondCircleRadius * Math.cos(angle);
        node.y = centerNode.fy + secondCircleRadius * Math.sin(angle);
        node.z = 0;
        node.fx = node.x;
        node.fy = node.y;
        node.fz = node.z;
    });
    console.log("Center Node Position:", centerNode);
    console.log("First Circle Nodes Position:", firstCircleNodes);
    console.log("Second Circle Nodes Position:", secondCircleNodes);
    // Manually refresh the graph
    Graph.d3ReheatSimulation();
    // Graph.refresh();

     // Create circle geometries
    const geometry3 = new THREE.CircleGeometry(secondCircleRadius, 100); // Adjust 100 to your outer circle radius
    const geometry1 = new THREE.CircleGeometry(firstCircleRadius, 100); // Adjust 100 to your outer circle radius
    const geometry2 = new THREE.CircleGeometry(50, 100);  // Adjust 50 to your inner circle radius
    
    // Create material
    const material = new THREE.LineBasicMaterial({ color: 0x202051 });
    
    // Create edge geometries
    const edges1 = new THREE.EdgesGeometry(geometry1);
    const edges2 = new THREE.EdgesGeometry(geometry2);
    const edges3 = new THREE.EdgesGeometry(geometry3);
    
    // Create line segments (wireframe circles)
    const circle1 = new THREE.LineSegments(edges1, material);
    const circle2 = new THREE.LineSegments(edges2, material);
    const circle3 = new THREE.LineSegments(edges3, material);

    // Assign names
    circle1.name = 'centerCircle';
    circle2.name = 'innerCircle';
    circle3.name = 'outerCircle';
    
    // Position circles at the center of your node layout
    circle1.position.set(0, 0, 0); // Adjust position as needed
    circle2.position.set(0, 0, 0); // Adjust position as needed
    circle3.position.set(0, 0, 0); // Adjust position as needed
    
    // Add circles to the graph scene
    Graph.scene().add(circle1);
    Graph.scene().add(circle2);
    Graph.scene().add(circle3);
}

    // Spread nodes a little wider
    // Graph.d3Force('charge').strength(-1000);

    // // Graph.scene().add(mesh);
    // const geometry = new THREE.BoxGeometry( 100, 100, 100 ); 
    // const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} ); 
    // const cube = new THREE.Mesh( geometry, material ); 
    // cube.position.set(-100, -50, 0);
    // cube.rotation.set(0, 0, 0);

    // // console.log(Graph.position.graph2ScreenCoords(1,2,3));
    // Graph.scene().add(cube);
    

  </script>
</body>